import Classes
import localizer

# create future heat map to predict the best location
# expand radius of head n steps, and delete body n cells from tail to head
# parameters: 
#   - steps_to_goals: list of steps our snake must take to each food location
#   - goals: list of possible food, food that is closer to us than other snakes
#   - graph
#   - start: our current location
# return list of heat maps corresponding to each food
def predict_heatmap(graph, start, goals, steps_to_goals):
    food_weight = {} # {food location (x,y): weight {(i,j): weight value}} track future maps of snakes' locations when expand heads x radius
    our_snake = graph.our_snake
    our_head = (our_snake['body'][0]['x'], our_snake['body'][0]['y'])
    cur_goal = 0 # track of current step, and food location in goals

    # expand other snakes' heads
    for snake in graph.snakes:
        head = (snake['body'][0]['x'], snake['body'][0]['y'])

        # length
        head_weight = localizer.SHORTER_SNAKE_HEAD if len(our_snake['body']) > len(
            snake['body']) else localizer.LONGER_SNAKE_HEAD

        if our_head != head:

            # weight of cells in radius 1 = length snake - steps to food
            # we want to number snake parts, starting from 0,1,2,... from tail to head

            # use BFS to expand snake HEAD
            step = 0
            q = Classes.Queue()
            q.put((head, 0))
            visited = set([head])
            weight = {}

            while cur_goal < len(steps_to_goals):
                steps_to_current_food = steps_to_goals[cur_goal]
                current_food_location = goals[cur_goal]

                while not q.empty() and step <= steps_to_current_food:
                    (cell, radius) = q.get()
                    step = radius + 1

                    # update weight
                    if step > steps_to_current_food:  # we reach future head location, update weight with head weight
                        weight[cell] = head_weight
                    else:
                        # replace head with body when the snake moves 1 step
                        weight[cell] = localizer.SNAKE_BODIES

                    for u in graph.neighbors(cell):
                        if u not in visited:
                            visited.add(u)
                            q.put((u, step))

                # remove snake TAIL
                for i in range(steps_to_current_food):
                    tail = (snake['body'][-1-i]['x'], snake['body'][-1-i]['y'])
                    weight[tail] = 0

                # record current head expansion of current snake after cur_goal steps
                if current_food_location not in food_weight:
                    food_weight[current_food_location] = weight
                else:
                    food_weight[current_food_location].update(weight)
                # next goal
                cur_goal += 1

    # update weight
    for food_coord, food_path in food_weight.items():
        board_weight = graph.weights.copy()
        board_weight.update(food_path)
        # food_path.update(board_weight)
        food_weight[food_coord] = board_weight

        visualize(board_weight, graph.width, graph.height) # DEBUG
    
    # for DEBUG with our snake only
    if len(graph.snakes) == 1:
        board_weight = graph.weights.copy()
        for food_coord in goals:
            food_weight[food_coord] = board_weight
    return food_weight

# check if future location has more adjacent empty cells than our length
def check_safe_location(graph, start, weight):
    obstacles = merge_two_dicts(graph.weights, weight) 
    visualize(obstacles, graph.width, graph.height) # DEBUG
    current_length = len(graph.our_snake['body']) + 1
    instance = 0
    q = Classes.Queue()
    q.put(start)
    visited = set([start])
    while not q.empty() and instance < current_length:
        cell = q.get()
        instance += 1
        for neighbor in future_neighbors(cell, graph.width, graph.height, obstacles):
            if neighbor not in visited:
                q.put(neighbor)
                visited.add(neighbor)
    if instance < current_length:
        return False
    return True


def merge_two_dicts(x, y):
    z = x.copy()
    z.update(y)
    return z

# possible neighbors around a point
# use weight generated by predict_heatmap to detect obstacles


def future_neighbors(id, width, height, obstacles):
    (x, y) = id
    results = [(x+1, y), (x, y-1), (x-1, y), (x, y+1)]
    results = filter(lambda x: 0 <= x[0] < width and 0 <= x[1] < height, results)
    results = filter(lambda x: x not in obstacles or obstacles[x] == 0, results)
    return list(results)

# board = {}
# want to see weights
def visualize(weight, width, height):
    # header
    header = '  '
    line = '--'
    for w in range(width):
        header += (str(w) + ' ') if w > 10 else (' ' + str(w) + ' ')
        line += '---'
    print(header)
    print(line)

    for i in range(height):
        s = str(i) + '|'
        for j in range(width):
            if (j, i) not in weight:
                s += '00 '
            elif weight[(j,i)] < 10:
                s += '0' + str(weight[(j,i)]) + ' '
            else:
                s += str(weight[(j,i)]) + ' '
        s.strip()
        print(s)
